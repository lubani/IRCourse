import string
from collections import Counter
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_extraction import DictVectorizer
from sklearn.naive_bayes import MultinomialNB
import numpy as np  # linear algebra
import pandas as pd  # data processing, CSV file I/O (e.g. pd.read_csv)
import os
from sklearn.model_selection import train_test_split
from tqdm import tqdm
# calculate accuracy of class predictions
from sklearn import metrics

# Create the vectorizer
vectorizer = TfidfVectorizer(norm='l2')


def preprocessing(csvFilePath):
    df = pd.read_csv(csvFilePath)
    print(df)
    # Truncate the dataframe to have the correct number of rows
    # df = df.head(13716)
    return df


def train(X_train, y_train):
    # Create an empty list to store the strings generated by the X_train iterable
    strings = []

    # Iterate over the elements of the X_train iterable and append each string to the strings list
    for i, stringi in enumerate(X_train):
        # Add a new item to the strings dictionary using the index of the item in the y_train Series as the key
        strings.append(stringi)

    # Create a numerical representation of the training data using the vectorizer
    X_set = vectorizer.fit_transform(strings)

    # Train the classifier
    clf = MultinomialNB()
    clf.fit(X_set, y_train)

    return clf


def predict(clf, X):
    # Create a numerical representation of the data to make predictions on using the vectorizer
    X_set = vectorizer.transform(X).toarray()

    # Make predictions using the classifier
    return clf.predict(X_set)


# First, create a function that generates new string values based on an existing string
def generate_augmented_string(string, label):
    # Generate a list of random characters to add to the string
    added_characters = np.random.choice(list(string.lower()), size=5)

    # Add the characters to the string at random positions
    for character in added_characters:
        # Generate a random position to insert the character
        position = np.random.randint(0, len(string))
        # Insert the character at the specified position
        augmented_string = string[:position] + character + string[position:]

    return augmented_string, label


csvFilePath = 'train.csv'
df = preprocessing(csvFilePath)

# Next, create a new DataFrame to hold the augmented data
augmented_data = pd.DataFrame(columns=['sms', 'label'])

# Sample a random subset of the data
sample_size = 14631 - df.shape[0]
df_sample = df.sample(sample_size, replace=True)

# Loop over the sampled data and generate new strings for each row
for _, row in df_sample.iterrows():
    # Get the original string and label
    string = row['sms']
    label = row['label']

    # Generate a new string based on the original string
    augmented_string, augmented_label = generate_augmented_string(string, label)

    # Add the new string and label to the augmented data DataFrame
    augmented_data = pd.concat([augmented_data, pd.DataFrame({'sms': [augmented_string], 'label':
        [augmented_label]})], ignore_index=True)

# Finally, concatenate the augmented data with the original data to create a new DataFrame
augmented_df = pd.concat([df, augmented_data], axis=0)
# Add the new data to the dataframe
# df = pd.concat([df, new_data], axis=1)
# Training data
X = augmented_df["sms"].astype(str)
y = augmented_df["label"].astype(int)
print(f'X = {X}, y = {y}')
# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
# Train the class
clf = train(X_train, y_train)
predictions = predict(clf, X_test)

# Create a DataFrame with the predictions and the actual labels
results = pd.DataFrame({"sms": X_test, "Predicted": predictions, "Actual": y_test})

print(metrics.accuracy_score(y_test, predictions))
print(metrics.confusion_matrix(y_test, predictions))
results.to_csv("results.csv")

# Filter the DataFrame to only include rows where the prediction was incorrect
incorrect_predictions_df = results[results['Predicted'] != y_test]

# Save the DataFrame to a CSV file
incorrect_predictions_df.to_csv('incorrect_predictions.csv', index=False)
